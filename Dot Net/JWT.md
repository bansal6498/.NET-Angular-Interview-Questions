## JWT Token
JWT (JSON Web Token) is an open standard (RFC 7519) that defines a compact and self-contained way for securely transmitting information between parties as a JSON object. It is often used for authentication and authorization in web applications.
### JWT Token Structure:
-   **Header:** Defines the algorithm used to sign the token (typically HS256 for HMACSHA256).
-   **Payload:** Contains the claims, such as user information (e.g., userId, roles).
-   **Signature:** Ensures the token has not been tampered with. It is generated by combining the encoded header, payload, and a secret key, then applying the signing algorithm.</br>

**Example JWT:**
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
-   Header (base64 encoded)
-   Payload (base64 encoded)
-   Signature (HMACSHA256 of the encoded header, payload, and secret key)
### Claims in JWT:
Claims are statements about an entity (usually the user) and additional metadata.
-   **Registered Claims:** Predefined claims like `iss` (issuer), sub (subject), `aud` (audience), `iat` (issued at), and `exp` (expiration time).
-   **Public Claims:** Claims that are not registered but can be used to store custom data.
-   **Private Claims:** Claims that are custom to your application and should be kept secure.
### How JWT Works:
1.  Client Requests Login: The client sends a username and password.
2.  Server Validates: If valid, the server generates a JWT token containing claims (such as user ID, roles) and sends it back to the client.
3.  Client Sends Token: For subsequent requests, the client sends the JWT token in the Authorization header as Bearer <token>.
4.  Server Validates Token: The server checks the token’s signature, validates the claims (expiration time, issuer, etc.), and authorizes the request.
### Benefits of JWT:
-   **Stateless:** No server-side session required.
-   **Compact:** Small size due to the use of base64 encoding.
-   **Self-contained:** Contains all the necessary information (like user identity) for authorization, reducing the need for database calls.
### JWT Authentication Process:
1.  **User Login:** The user logs in with their credentials.
2.  **Token Generation:** The server validates the credentials and generates a JWT token containing claims (such as user ID, roles, etc.).
3.  **Client Stores Token:** The client stores the token (usually in localStorage or sessionStorage).
4.  **Token Sent with Requests:** For every subsequent request, the client sends the token in the Authorization header using the format Bearer <token>.
5.  **Token Validation:** The server validates the JWT token and decodes the claims to identify the user.
### JWT Implementation in .NET
**1.  Install NuGet Packages:**
-   `Microsoft.AspNetCore.Authentication.JwtBearer`
-   `System.IdentityModel.Tokens.Jwt`
**2. Configure Authentication in Startup.cs:** In the `ConfigureServices` method, add the following:
```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
        .AddJwtBearer(options =>
    {
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuer = true,
            ValidateAudience = true,
            ValidateLifetime = true,
            ValidateIssuerSigningKey = true,
            ValidIssuer = "your-issuer",
            ValidAudience = "your-audience",
            IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes("your-secure-key"))
        };
    });
}
```
**3. Generate JWT Token:**
```csharp
public string GenerateJwtToken(string userId)
{
    var claims = new[]
    {
        new Claim(JwtRegisteredClaimNames.Sub, userId),
        new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString())
    };
    var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes("your-secure-key"));
    var creds = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);
    var token = new JwtSecurityToken(
        issuer: "your-issuer",
        audience: "your-audience",
        claims: claims,
        expires: DateTime.Now.AddMinutes(30),
        signingCredentials: creds
    );
    return new JwtSecurityTokenHandler().WriteToken(token);
}
```
**4. Use JWT in the Controller:**
```csharp
[Authorize]
[HttpGet]
public IActionResult GetUserDetails()
{
    var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    return Ok(new { userId });
}
```
#### What are the security concerns in token-based authentication?
**Answer:**
Token theft, expiration handling, and secure storage of tokens (e.g., in localStorage).
#### Best Practice
-   Use HTTPS to secure token transmission.
-   Implement token expiration and refresh mechanisms.
-   Do not store tokens in insecure places like plain cookies.
-   Use role-based or claim-based authorization for fine-grained access control
### Conclusion
Authentication and authorization are essential components of securing an application, and .NET provides multiple ways to handle them. JWT offers a flexible and scalable way to authenticate users in modern web applications. By understanding the differences between authentication and authorization and mastering the implementation of JWT, developers can build secure, scalable applications.
#### How to handle JWT token theft?
**Answer:**
Short list of practical defenses and mitigation steps:
-   Short-lived access tokens (e.g., 5–15 minutes) + refresh tokens for session continuity.
-   Refresh token rotation: issue a new refresh token on each use and revoke the previous one (detect reuse → revoke session).
-   Store refresh tokens securely (HttpOnly, Secure cookies or secure storage) — never store long-lived tokens in plain localStorage if XSS is a concern.
-   Blacklist / revocation store: keep server-side blacklist (or use token reference IDs / `jti`) so you can revoke tokens before expiry. Use token introspection for reference tokens.
-   Detect anomalies: IP/geolocation/device changes, impossible travel, rapid requests → force re-auth or revoke tokens.
-   Revoke on logout(s): record active tokens per user and clear them when needed.
-   Bind tokens to device or client (fingerprint) when appropriate — increases complexity but raises the bar for attackers.
-   MFA for sensitive actions and revalidation for critical flows.
-   Use TLS everywhere and apply Content Security Policy (CSP) to reduce XSS risk.
-   Limit scope/privileges encoded in tokens; use claims tightly.
-   Monitor & alert on suspicious token activity.

Example pattern: short access token + rotating refresh token stored HttpOnly cookie + server-side refresh token DB with `jti, expires, revoked` flags and last-used timestamp. On reuse of a revoked/rotated refresh token, revoke all sessions and force re-login.</br>
#### Access Token
-   An Access Token is a credential issued to a client after successful authentication.
-   It proves the identity and grants access to protected resources.
-   In .NET Core, usually a JWT.
-   Used in `Authorization: Bearer <token> header`.</br>

✅ Difference from Refresh Token:
-   **Access Token** → short-lived, used for API access.
-   **Refresh Token** → long-lived, used to get new access tokens without logging in again.